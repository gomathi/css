The solution is provided as css.zip, and it contains the following

Artifacts
----------	

1. css-master.zip,  Source code
2. css.jar, Executable jar file (this executable version was tested with java version "1.8.0_161")
3. daemons_config.json, contains the configuration for the shelves, min/max delays for the pickup service, and poisson mean. These configurations can be changed dynamically.
4. Engineering_Challenge_-_Orders.json, contains 132 orders provided as part of the exercise.
5. css.log, a sample log generated by the fulfillment daemons during the test run with 132 orders.
6. orders_delivery_with_low_pickup_delay.csv, provides info on 132 orders how it was served(expired?, served?) during fulfillment service's run with low pickup delay(threads were picking up the orders from shelf with 2ms to 10ms delay.)
7.orders_delivery_with_high_pickup_delay.csv, provides info on 132 orders how it was served(expired?, served?) during fulfillment service's run with low pickup delay(threads were picking up the orders from shelf with 20ms to 25ms delay.)

Running the code
----------------
(assuming css.zip is extracted under /workplace)

java -DconfigFile=/workplace/css/daemons_config.json -DordersFile=/workplace/css/Engineering_Challenge_-_Orders.json -jar /workplace/css/css.jar 2>&1 | tee /tmp/css.log

The log provides more detailed information about how the fulfillment service performed during its execution.

If you want to get just a summary of what happened to the orders, then you can run the following command

grep orderInfo /tmp/css.log | awk -F' - ' '{print $2}' | awk -F'{' '{print $2}' | awk -F'}' '{print $1}' > /tmp/orders.csv

Also you are provided with csv that were generated during previous fulfillment service's run. Look at (6) & (7) under Artifacts.

You can change configuration of the fulfillment service(you can't remove any shelves), the following options are possible

 1. changing the capacity of any shelves, how fast the overflow shelf decays(currently it decays twice as fast as regular shelves, you can try changing it to 3x, in unit testing I have tried with 10x to make the test cases run faster.)
 2. poisson distribution's mean(in the assignment it was mentioned as 3.25, we can change this value and see how the fulfillment service performs)
 3. changing min and max delays of driver arrival.

Architecture and design choices around Overflow shelf management
------------------------------------------------------------------

The design goal I have chosen is to reduce the kitchen wastage - i.e., dispatch the orders before they get expired in the fulfillment service.

How I achieved the goal

1. All shelves use the same priority queue(along with multi threaded guarantees, and with separate counting semaphores for each shelf that controls addition/removal to the same queue). This way, across all shelves whichever order is going to expire sooner will get the priority for the pickup. 

2. A mover thread(not busy thread, uses blocking techniques on both consuming and producing ends) is assigned for all (overflow shelf, regular shelf) pairs. Whenever a thread finds space on the regular shelf, it moves corresponding order from overflow shelf to regular shelf. This is important as decayRate doubles in overflow shelf, so orders will expire sooner. These threads help in reducing the expiry on the shelf, also allows overflow shelf to be available as a backup for other regular shelves.

3. The shelves need to be cleaned as soon as the orders expire. This becomes critical in case of pickup service's delay. In such cases, if the orders are not removed from regular shelves, then overflow shelf can't move the orders back to regular shelves, and the orders in the overflow shelf also will get expired, also any new orders that are coming to a regular shelf which is full will get expired even before it gets a space on the shelf. Here DelayQueue is used for removing expired orders. In a DelayQueue you can remove an order only if its expired. All updates that are happening on the main queue are updated on the delay queue as well. So delay queue will contain only orders which need to be tracked for expiry, and a thread blocks on this delay queue, and if it can remove an order from the delay queue, then it will mark the order as expired. 

4. Additionally any addition to the fulfillment service is executed in O(log n) time and removal of an order for pickup happens in O(1) time. So this complexity is better in case if the shelf capacities increases in future. Space wise I am using additionally 1.25x of the capacity of all shelves only. The background threads may get into performing some linear time operations like removing an order for expiry, and moving an order, but they don't impact any online operations. Additionally if pickup service is maintaining the SLAs in delivering an order from the shelf, then these threads wont have to perform many operations. So in that case, these background threads will have less load on the system.



